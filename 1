See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Spotbugs:     PASSED
PMD:          PASSED
Checkstyle:   PASSED

Correctness:  32/41 tests passed
Memory:       1/1 tests passed
Timing:       41/41 tests passed

Aggregate score: 86.83%
[Compilation: 5%, API: 5%, Spotbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
3.4K Aug 14 11:43 BruteCollinearPoints.java
4.0K Aug 14 11:43 FastCollinearPoints.java
1.9K Aug 14 11:43 LineSegment.java
3.5K Aug 14 11:43 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac Point.java
*-----------------------------------------------------------

% javac LineSegment.java
*-----------------------------------------------------------

% javac BruteCollinearPoints.java
*-----------------------------------------------------------

% javac FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% spotbugs *.class
*-----------------------------------------------------------


================================================================


% pmd .
*-----------------------------------------------------------


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
==> passed


Total: 3/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
  * filename = horizontal25.txt
==> passed

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
  * 10 random horizontal line segments
  * 15 random horizontal line segments
==> passed

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
==> passed

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> passed

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 9: random line segments
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
  * equidistant.txt
==> passed

Test 11: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 17/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
    - number of entries in student   solution: 3
    - number of entries in reference solution: 4
    - 1 missing entry in student solution:
      '(10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)'


  * filename = input40.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 6
    - 5 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 6
    - 4 missing entries in student solution, including:
      '(7300, 10050) -> (7300, 10450) -> (7300, 25700) -> (7300, 31650)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
  * filename = horizontal25.txt
  * filename = horizontal50.txt
  * filename = horizontal75.txt
  * filename = horizontal100.txt
==> passed

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
  * 10 random horizontal line segments
  * 15 random horizontal line segments
==> passed

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
  * filename = vertical50.txt
  * filename = vertical75.txt
  * filename = vertical100.txt
==> passed

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> passed

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
  * filename = input10.txt
  * filename = input20.txt
    - segments() contains the same segment more than once
    - segment 4: (4096, 25088) -> (4096, 24064)
    - segment 6: (4096, 25088) -> (4096, 24064)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (4096, 22016) -> (4096, 25088)
    - reference segment 3: (4096, 20992) -> (4096, 22016) -> (4096, 23040) -> (4096, 24064) -> (4096, 25088)

    - number of entries in student   solution: 8
    - number of entries in reference solution: 5
    - 4 extra entries in student solution, including:
      '(4096, 25088) -> (4096, 24064)'

    - 1 missing entry in student solution:
      '(8192, 25088) -> (8192, 26112) -> (8192, 27136) -> (8192, 28160) -> (8192, 29184)'


  * filename = input50.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (1000, 9000) -> (1000, 26000)
    - reference segment 5: (1000, 2000) -> (1000, 9000) -> (1000, 13000) -> (1000, 23000) -> (1000, 26000)

    - number of entries in student   solution: 3
    - number of entries in reference solution: 7
    - 1 extra entry in student solution:
      '(1000, 9000) -> (1000, 26000)'

    - 5 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input80.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (25000, 9000) -> (25000, 31000)
    - reference segment 28: (25000, 8000) -> (25000, 9000) -> (25000, 12000) -> (25000, 27000) -> (25000, 29000) -> (25000, 31000)

    - number of entries in student   solution: 9
    - number of entries in reference solution: 31
    - 6 extra entries in student solution, including:
      '(25000, 31000) -> (25000, 29000)'

    - 28 missing entries in student solution, including:
      '(13000, 29000) -> (19000, 29000) -> (25000, 29000) -> (28000, 29000)'


  * filename = input300.txt
    - number of entries in student   solution: 3
    - number of entries in reference solution: 6
    - 3 missing entries in student solution, including:
      '(23000, 8500) -> (29550, 8500) -> (30000, 8500) -> (30950, 8500)'


  * filename = inarow.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (30000, 0) -> (25000, 0)
    - reference segment 1: (0, 0) -> (5000, 0) -> (10000, 0) -> (15000, 0) -> (20000, 0) -> (25000, 0) -> (30000, 0)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(30000, 0) -> (25000, 0)'

    - 2 missing entries in student solution, including:
      '(5000, 0) -> (10000, 3100) -> (15000, 6200) -> (20000, 9300) -> (25000, 12400)'


==> FAILED

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
    - segments() contains the same segment more than once
    - segment 94: (18010, 10832) -> (17870, 10726)
    - segment 98: (18010, 10832) -> (17870, 10726)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 8: (10928, 580) -> (11669, 1741)
    - reference segment 219: (10681, 193) -> (10928, 580) -> (11175, 967) -> (11422, 1354) -> (11669, 1741)

    - number of entries in student   solution: 317
    - number of entries in reference solution: 288
    - 124 extra entries in student solution, including:
      '(12652, 30395) -> (12142, 30061)'

    - 95 missing entries in student solution, including:
      '(16384, 30255) -> (15979, 30308) -> (15574, 30361) -> (15169, 30414) -> (14764, 30467)'


  * filename = rs1423.txt
    - number of entries in student   solution: 237
    - number of entries in reference solution: 443
    - 206 missing entries in student solution, including:
      '(14169, 27672) -> (13927, 27810) -> (13685, 27948) -> (13443, 28086)'


==> FAILED

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - number of entries in student   solution: 3
    - number of entries in reference solution: 4
    - 1 missing entry in student solution:
      '(10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)'


  * filename = input40.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 6
    - 5 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 6
    - 4 missing entries in student solution, including:
      '(7300, 10050) -> (7300, 10450) -> (7300, 25700) -> (7300, 31650)'


==> FAILED

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - number of entries in student   solution: 3
    - number of entries in reference solution: 4
    - 1 missing entry in student solution:
      '(10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)'


  * filename = input40.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 6
    - 5 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 9: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 25 random line segments
    - number of entries in student   solution: 24
    - number of entries in reference solution: 25
    - 1 missing entry in student solution:
      '(10392, 4762) -> (10684, 8142) -> (10903, 10677) -> (11341, 15747)'


    - failed on trial 26 of 100

  * 50 random line segments
    - number of entries in student   solution: 49
    - number of entries in reference solution: 50
    - 1 missing entry in student solution:
      '(5042, 7337) -> (5152, 9407) -> (5394, 13961) -> (5416, 14375)'


    - failed on trial 2 of 15

  * 100 random line segments
==> FAILED

Test 10: random line segments
  *  1 random line segment
  *  5 random line segments
  * 25 random line segments
  * 50 random line segments
    - number of entries in student   solution: 49
    - number of entries in reference solution: 50
    - 1 missing entry in student solution:
      '(7140, 5288) -> (7140, 5563) -> (7140, 6038) -> (7140, 7038)'


    - failed on trial 6 of 15

  * 100 random line segments
==> FAILED

Test 11: random distinct points in a given range
  * 5 random points in a 10-by-10 grid
  * 10 random points in a 10-by-10 grid
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution:
      '(1, 5) -> (3, 6) -> (5, 7) -> (7, 8)'


    - failed on trial 2 of 500
     10
         5     9
         4     5
         3     1
         0     4
         7     8
         3     5
         3     6
         7     3
         1     5
         5     7

  * 50 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 9: (8, 1) -> (7, 1)
    - segment 12: (8, 1) -> (7, 1)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 6: (6, 1) -> (8, 1)
    - reference segment 13: (0, 1) -> (2, 1) -> (6, 1) -> (7, 1) -> (8, 1)

    - number of entries in student   solution: 38
    - number of entries in reference solution: 41
    - 20 extra entries in student solution, including:
      '(9, 6) -> (8, 6)'

    - 23 missing entries in student solution, including:
      '(0, 9) -> (1, 9) -> (3, 9) -> (6, 9)'


    - failed on trial 1 of 100

  * 90 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 28: (9, 0) -> (8, 0)
    - segment 33: (9, 0) -> (8, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 5: (2, 0) -> (9, 0)
    - reference segment 55: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 133
    - number of entries in reference solution: 127
    - 87 extra entries in student solution, including:
      '(9, 7) -> (9, 9)'

    - 81 missing entries in student solution, including:
      '(0, 9) -> (1, 9) -> (2, 9) -> (4, 9) -> (5, 9) -> (6, 9) -> (7, 9) -> (9, 9)'


    - failed on trial 1 of 50

  * 200 random points in a 50-by-50 grid
    - segments() contains the same segment more than once
    - segment 16: (43, 1) -> (24, 1)
    - segment 18: (43, 1) -> (24, 1)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 9: (1, 1) -> (1, 33)
    - reference segment 207: (1, 0) -> (1, 1) -> (1, 5) -> (1, 27) -> (1, 33)

    - number of entries in student   solution: 140
    - number of entries in reference solution: 237
    - 90 extra entries in student solution, including:
      '(48, 43) -> (44, 39)'

    - 187 missing entries in student solution, including:
      '(7, 49) -> (12, 49) -> (17, 49) -> (23, 49) -> (25, 49) -> (33, 49) -> (34, 49) -> (43, 49)'


    - failed on trial 1 of 10

==> FAILED

Test 12: m*n points on an m-by-n grid
  * 3-by-3 grid
  * 4-by-4 grid
    - number of entries in student   solution: 3
    - number of entries in reference solution: 10
    - 7 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3)'


  * 5-by-5 grid
    - segments() contains the same segment more than once
    - segment 5: (4, 0) -> (3, 0)
    - segment 8: (4, 0) -> (3, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (2, 0) -> (4, 0)
    - reference segment 3: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0)

    - number of entries in student   solution: 17
    - number of entries in reference solution: 16
    - 8 extra entries in student solution, including:
      '(4, 2) -> (4, 4)'

    - 7 missing entries in student solution, including:
      '(0, 4) -> (1, 4) -> (2, 4) -> (3, 4) -> (4, 4)'


  * 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 36: (9, 0) -> (8, 0)
    - segment 41: (9, 0) -> (8, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 5: (2, 0) -> (9, 0)
    - reference segment 67: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 168
    - number of entries in reference solution: 154
    - 106 extra entries in student solution, including:
      '(9, 7) -> (9, 9)'

    - 92 missing entries in student solution, including:
      '(0, 9) -> (1, 9) -> (2, 9) -> (3, 9) -> (4, 9) -> (5, 9) -> (6, 9) -> (7, 9) -> (8, 9) -> (9, 9)'


  * 20-by-20 grid
    - segments() contains the same segment more than once
    - segment 252: (19, 0) -> (18, 0)
    - segment 265: (19, 0) -> (18, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 13: (2, 0) -> (19, 0)
    - reference segment 1203: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0) -> (15, 0) -> (16, 0) -> (17, 0) -> (18, 0) -> (19, 0)

    - number of entries in student   solution: 2082
    - number of entries in reference solution: 2446
    - 1358 extra entries in student solution, including:
      '(19, 17) -> (19, 19)'

    - 1722 missing entries in student solution, including:
      '(0, 19) -> (1, 19) -> (2, 19) -> (3, 19) -> (4, 19) -> (5, 19) -> (6, 19) -> (7, 19) -> (8, 19) -> (9, 19) -> (10, 19) -> (11, 19) -> (12, 19) -> (13, 19) -> (14, 19) -> (15, 19) -> (16, 19) -> (17, 19) -> (18, 19) -> (19, 19)'


  * 5-by-4 grid
    - segments() contains the same segment more than once
    - segment 3: (4, 0) -> (3, 0)
    - segment 5: (4, 0) -> (3, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2, 0) -> (4, 0)
    - reference segment 2: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0)

    - number of entries in student   solution: 8
    - number of entries in reference solution: 13
    - 4 extra entries in student solution, including:
      '(4, 1) -> (3, 1)'

    - 9 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3)'


  * 6-by-4 grid
    - segments() contains the same segment more than once
    - segment 5: (5, 0) -> (4, 0)
    - segment 7: (5, 0) -> (4, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2, 0) -> (5, 0)
    - reference segment 3: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0)

    - number of entries in student   solution: 10
    - number of entries in reference solution: 16
    - 5 extra entries in student solution, including:
      '(5, 1) -> (4, 1)'

    - 11 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3)'


  * 10-by-4 grid
    - segments() contains the same segment more than once
    - segment 13: (9, 0) -> (8, 0)
    - segment 15: (9, 0) -> (8, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2, 0) -> (9, 0)
    - reference segment 12: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 18
    - number of entries in reference solution: 38
    - 9 extra entries in student solution, including:
      '(9, 1) -> (8, 1)'

    - 29 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3) -> (6, 3) -> (7, 3) -> (8, 3) -> (9, 3)'


  * 15-by-4 grid
    - segments() contains the same segment more than once
    - segment 23: (14, 0) -> (13, 0)
    - segment 25: (14, 0) -> (13, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2, 0) -> (14, 0)
    - reference segment 30: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0)

    - number of entries in student   solution: 28
    - number of entries in reference solution: 79
    - 14 extra entries in student solution, including:
      '(14, 1) -> (13, 1)'

    - 65 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3) -> (6, 3) -> (7, 3) -> (8, 3) -> (9, 3) -> (10, 3) -> (11, 3) -> (12, 3) -> (13, 3) -> (14, 3)'


  * 25-by-4 grid
    - segments() contains the same segment more than once
    - segment 43: (24, 0) -> (23, 0)
    - segment 45: (24, 0) -> (23, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2, 0) -> (24, 0)
    - reference segment 92: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0) -> (15, 0) -> (16, 0) -> (17, 0) -> (18, 0) -> (19, 0) -> (20, 0) -> (21, 0) -> (22, 0) -> (23, 0) -> (24, 0)

    - number of entries in student   solution: 48
    - number of entries in reference solution: 213
    - 24 extra entries in student solution, including:
      '(24, 1) -> (23, 1)'

    - 189 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3) -> (6, 3) -> (7, 3) -> (8, 3) -> (9, 3) -> (10, 3) -> (11, 3) -> (12, 3) -> (13, 3) -> (14, 3) -> (15, 3) -> (16, 3) -> (17, 3) -> (18, 3) -> (19, 3) -> (20, 3) -> (21, 3) -> (22, 3) -> (23, 3) -> (24, 3)'


==> FAILED

Test 13: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
  * equidistant.txt
==> passed

Test 14: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 15: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 16: throws an exception if either constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
==> passed

Test 17: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 12/21 tests passed!


================================================================
********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of Point
*-----------------------------------------------------------
Running 1 total tests.

The maximum amount of memory per Point object is 32 bytes.

Student memory = 24 bytes (passed)

Total: 1/1 tests passed!


================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing BruteCollinearPoints
*-----------------------------------------------------------
Running 10 total tests.

Test 1a-1e: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.00           0         455            910                   62
=> passed    32   0.00           0        4495           8990                  153
=> passed    64   0.00           0       39711          79422                  366
=> passed   128   0.01           0      333375         666750                  873
=> passed   256   0.03           0     2731135        5462270                 1963
==> 5/5 tests passed

Test 2a-2e: Find collinear points among n/4 arbitrary line segments


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    16   0.00           0         542           1084                   59
=> passed    32   0.00           0        4874           9748                  154
=> passed    64   0.00           0       41209          82418                  366
=> passed   128   0.01           0      339582         679164                  865
=> passed   256   0.04           0     2757816        5515632                 1996
==> 5/5 tests passed

Total: 10/10 tests passed!


================================================================



Timing FastCollinearPoints
*-----------------------------------------------------------
Running 31 total tests.

Test 1a-1g: Find collinear points among n random distinct points


                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.01        8064       18696          45456                19213
=> passed   128   0.01       32512       88389         209290                89635
=> passed   256   0.04      130560      414913         960386               415813
=> passed   512   0.20      523264     1892938        4309140              1896863
=> passed  1024   0.47     2095104     8540090       19175284              8566985
=> passed  2048   1.30     8384512    38072182       84528876             38179949
==> 6/6 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (84528876 / 19175284) = 2.14
=> passed

==> 7/7 tests passed

Test 2a-2g: Find collinear points among the n points on an n-by-1 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        8064        4764          17592                 7374
=> passed   128   0.00       32512       17796          68104                23806
=> passed   256   0.00      130560       68717         267994                81782
=> passed   512   0.01      523264      269399        1062062               297044
=> passed  1024   0.03     2095104     1065026        4225156              1122830
=> passed  2048   0.07     8384512     4231214       16846940              4351488
=> passed  4096   0.25    33546240    16859163       67264566             17108400
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (67264566 / 16846940) = 2.00
=> passed

==> 8/8 tests passed

Test 3a-3g: Find collinear points among the n points on an n/4-by-4 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        8064       14906          37876                17121
=> passed   128   0.00       32512       43854         120220                63698
=> passed   256   0.01      130560      149618         429796               241145
=> passed   512   0.02      523264      548156        1619576               926709
=> passed  1024   0.07     2095104     2087496        6270096              3610661
=> passed  2048   0.23     8384512     8122445       24629402             14183616
=> passed  4096   0.91    33546240    31990953       97528146             56102852
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (97528146 / 24629402) = 1.99
=> passed

==> 8/8 tests passed

Test 4a-4g: Find collinear points among the n points on an n/8-by-8 grid

                                                      slopeTo()
             n    time     slopeTo()   compare()  + 2*compare()        compareTo()
-----------------------------------------------------------------------------------------------
=> passed    64   0.00        8064       18045          44154                19191
=> passed   128   0.00       32512       75863         184238                85781
=> passed   256   0.01      130560      232229         595018               340235
=> passed   512   0.03      523264      854545        2232354              1336345
=> passed  1024   0.15     2095104     3260991        8617086              5288766
=> passed  2048   0.58     8384512    12699218       33782948             21035418
=> passed  4096   1.65    33546240    50043244      133632728             83781336
==> 7/7 tests passed

lg ratio(slopeTo() + 2*compare()) = lg (133632728 / 33782948) = 1.98
=> passed

==> 8/8 tests passed

Total: 31/31 tests passed!


================================================================



